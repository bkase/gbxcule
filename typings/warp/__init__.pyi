"""Type stubs for NVIDIA Warp."""

from typing import Any, Callable, Generic, Literal, TypeVar, overload

# Type variables
T = TypeVar("T")
DType = TypeVar("DType")

# Warp scalar types that support arithmetic operations
class int8(int): ...
class int16(int): ...
class int32(int): ...
class int64(int): ...
class uint8(int): ...
class uint16(int): ...
class uint32(int): ...
class uint64(int): ...
class float16(float): ...
class float32(float): ...
class float64(float): ...

# Array type - callable form for kernel parameter annotations
class array(Generic[DType]):
    dtype: type[DType]
    shape: tuple[int, ...]
    device: str

    @overload
    def __new__(cls, data: Any = ..., dtype: type[DType] = ..., device: str = ..., **kwargs: Any) -> "array[DType]": ...
    @overload
    def __new__(cls, *, dtype: type[DType], **kwargs: Any) -> type["array[DType]"]: ...
    def __new__(cls, *args: Any, **kwargs: Any) -> Any: ...

    def __getitem__(self, idx: int | tuple[int, ...]) -> DType: ...
    def __setitem__(self, idx: int | tuple[int, ...], value: Any) -> None: ...
    def __len__(self) -> int: ...

    def numpy(self) -> Any: ...  # Returns numpy array
    def to(self, device: str) -> "array[DType]": ...

# Empty array creation
def empty(shape: int | tuple[int, ...], dtype: type[T] = ..., device: str = ..., **kwargs: Any) -> array[T]: ...
def zeros(shape: int | tuple[int, ...], dtype: type[T] = ..., device: str = ..., **kwargs: Any) -> array[T]: ...
def ones(shape: int | tuple[int, ...], dtype: type[T] = ..., device: str = ..., **kwargs: Any) -> array[T]: ...
def full(shape: int | tuple[int, ...], value: Any, dtype: type[T] = ..., device: str = ..., **kwargs: Any) -> array[T]: ...
def from_numpy(arr: Any, dtype: type[T] | None = ..., device: str = ...) -> array[T]: ...

# Decorators
def kernel(fn: Callable[..., Any]) -> Callable[..., Any]: ...
def func(fn: Callable[..., T]) -> Callable[..., T]: ...

# Kernel launch
def launch(
    kernel: Callable[..., Any],
    dim: int | tuple[int, ...],
    inputs: list[Any] = ...,
    outputs: list[Any] = ...,
    device: str = ...,
    **kwargs: Any,
) -> None: ...

# Thread index
def tid() -> int: ...

# Math/utility functions
def where(cond: Any, x: T, y: T) -> T: ...
def min(a: Any, b: Any) -> Any: ...
def max(a: Any, b: Any) -> Any: ...
def abs(x: Any) -> Any: ...
def clamp(x: Any, lo: Any, hi: Any) -> Any: ...
def sqrt(x: Any) -> Any: ...
def floor(x: Any) -> Any: ...
def ceil(x: Any) -> Any: ...

# Synchronization
def synchronize() -> None: ...
def synchronize_device(device: str = ...) -> None: ...

# Device management
def is_cuda_available() -> bool: ...
def get_device(name: str = ...) -> Any: ...
def get_cuda_device_count() -> int: ...
def get_cuda_device(ordinal: int = ...) -> Any: ...
def set_device(device: str) -> None: ...

# Configuration
def init() -> None: ...

class _Config:
    mode: str
    verbose: bool
    verify_fp: bool
    print_launches: bool
    cache_kernels: bool

config: _Config

# Atomic operations
def atomic_add(arr: array[T], idx: int, value: Any) -> T: ...
def atomic_sub(arr: array[T], idx: int, value: Any) -> T: ...
def atomic_min(arr: array[T], idx: int, value: Any) -> T: ...
def atomic_max(arr: array[T], idx: int, value: Any) -> T: ...

# Version
__version__: str

# Constants
constant: Any
