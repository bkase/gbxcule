"""Tests for pyboy_vec_mp backend reliability.

Tests cover:
- Backend initialization with multiple workers
- reset() and step() work without hangs
- close() joins workers cleanly
- get_cpu_state() returns canonical keys
- Deterministic seeding produces stable derived seeds
"""

from __future__ import annotations

from pathlib import Path

import numpy as np
import pytest

from gbxcule.backends import ACTION_NOOP, ACTION_UP, NUM_ACTIONS
from gbxcule.backends.pyboy_vec_mp import PyBoyMpConfig, PyBoyVecMpBackend

# Path to test ROM (generated by micro-ROM builder)
ROM_PATH = Path(__file__).parent.parent / "bench" / "roms" / "out" / "ALU_LOOP.gb"


@pytest.fixture
def backend() -> PyBoyVecMpBackend:
    """Create a backend instance for testing."""
    if not ROM_PATH.exists():
        pytest.skip(f"Test ROM not found: {ROM_PATH}")
    return PyBoyVecMpBackend(str(ROM_PATH), num_envs=4, num_workers=2, obs_dim=32)


class TestConfig:
    """Tests for PyBoyMpConfig validation."""

    def test_valid_config(self) -> None:
        """Valid configuration is accepted."""
        if not ROM_PATH.exists():
            pytest.skip(f"Test ROM not found: {ROM_PATH}")
        config = PyBoyMpConfig(
            num_envs=4,
            num_workers=2,
            frames_per_step=24,
            release_after_frames=8,
            rom_path=str(ROM_PATH),
        )
        assert config.num_envs == 4
        assert config.num_workers == 2

    def test_invalid_num_envs(self) -> None:
        """num_envs < 1 raises ValueError."""
        if not ROM_PATH.exists():
            pytest.skip(f"Test ROM not found: {ROM_PATH}")
        with pytest.raises(ValueError, match="num_envs must be >= 1"):
            PyBoyMpConfig(
                num_envs=0,
                num_workers=1,
                frames_per_step=24,
                release_after_frames=8,
                rom_path=str(ROM_PATH),
            )

    def test_invalid_num_workers(self) -> None:
        """num_workers < 1 raises ValueError."""
        if not ROM_PATH.exists():
            pytest.skip(f"Test ROM not found: {ROM_PATH}")
        with pytest.raises(ValueError, match="num_workers must be >= 1"):
            PyBoyMpConfig(
                num_envs=4,
                num_workers=0,
                frames_per_step=24,
                release_after_frames=8,
                rom_path=str(ROM_PATH),
            )

    def test_workers_exceed_envs(self) -> None:
        """num_workers > num_envs raises ValueError."""
        if not ROM_PATH.exists():
            pytest.skip(f"Test ROM not found: {ROM_PATH}")
        with pytest.raises(ValueError, match="cannot exceed"):
            PyBoyMpConfig(
                num_envs=2,
                num_workers=4,
                frames_per_step=24,
                release_after_frames=8,
                rom_path=str(ROM_PATH),
            )

    def test_invalid_release_frames(self) -> None:
        """release_after_frames > frames_per_step raises ValueError."""
        if not ROM_PATH.exists():
            pytest.skip(f"Test ROM not found: {ROM_PATH}")
        with pytest.raises(ValueError, match="cannot exceed"):
            PyBoyMpConfig(
                num_envs=4,
                num_workers=2,
                frames_per_step=10,
                release_after_frames=20,
                rom_path=str(ROM_PATH),
            )


class TestBackendInit:
    """Tests for backend initialization."""

    def test_backend_attributes(self, backend: PyBoyVecMpBackend) -> None:
        """Backend has correct static attributes."""
        assert backend.name == "pyboy_vec_mp"
        assert backend.device == "cpu"
        assert backend.num_envs == 4

    def test_action_spec(self, backend: PyBoyVecMpBackend) -> None:
        """Action spec has correct shape and dtype."""
        spec = backend.action_spec
        assert spec.shape == (4,)
        assert spec.dtype == "int32"

    def test_obs_spec(self, backend: PyBoyVecMpBackend) -> None:
        """Obs spec has correct shape and dtype."""
        spec = backend.obs_spec
        assert spec.shape == (4, 32)
        assert spec.dtype == "float32"


class TestResetAndStep:
    """Tests for reset() and step() reliability."""

    def test_reset_returns_obs_and_info(self, backend: PyBoyVecMpBackend) -> None:
        """reset() returns tuple of (obs, info)."""
        try:
            obs, info = backend.reset(seed=123)
            assert isinstance(obs, np.ndarray)
            assert isinstance(info, dict)
        finally:
            backend.close()

    def test_reset_obs_shape(self, backend: PyBoyVecMpBackend) -> None:
        """reset() obs has correct shape."""
        try:
            obs, _ = backend.reset(seed=123)
            assert obs.shape == (4, 32)
        finally:
            backend.close()

    def test_reset_obs_dtype(self, backend: PyBoyVecMpBackend) -> None:
        """reset() obs has dtype float32."""
        try:
            obs, _ = backend.reset(seed=123)
            assert obs.dtype == np.float32
        finally:
            backend.close()

    def test_reset_info_contains_seed(self, backend: PyBoyVecMpBackend) -> None:
        """reset() info contains seed information."""
        try:
            _, info = backend.reset(seed=123)
            assert info["seed"] == 123
            assert "rom_sha256" in info
        finally:
            backend.close()

    def test_step_small_count_no_hang(self, backend: PyBoyVecMpBackend) -> None:
        """step() runs 8 times without hanging."""
        try:
            backend.reset(seed=123)
            actions = np.zeros((4,), dtype=np.int32)  # All noop

            for _ in range(8):
                obs, reward, done, trunc, info = backend.step(actions)
                assert obs.shape == (4, 32)
                assert reward.shape == (4,)
                assert done.shape == (4,)
                assert trunc.shape == (4,)
        finally:
            backend.close()

    def test_step_with_various_actions(self, backend: PyBoyVecMpBackend) -> None:
        """step() handles different action values correctly."""
        try:
            backend.reset(seed=123)

            # Test with different actions per env
            for _ in range(4):
                actions = np.array([ACTION_NOOP, ACTION_UP, 5, 7], dtype=np.int32)
                obs, _, _, _, _ = backend.step(actions)
                assert obs.shape == (4, 32)
        finally:
            backend.close()

    def test_step_without_reset_raises(self, backend: PyBoyVecMpBackend) -> None:
        """step() without reset raises RuntimeError."""
        actions = np.zeros((4,), dtype=np.int32)
        with pytest.raises(RuntimeError, match="not initialized"):
            backend.step(actions)


class TestGetCpuState:
    """Tests for get_cpu_state() via RPC."""

    def test_get_cpu_state_env0(self, backend: PyBoyVecMpBackend) -> None:
        """get_cpu_state(0) returns canonical keys."""
        try:
            backend.reset(seed=123)
            state = backend.get_cpu_state(0)

            # Check all canonical register keys
            for key in ["pc", "sp", "a", "f", "b", "c", "d", "e", "h", "l"]:
                assert key in state, f"Missing register: {key}"
                assert isinstance(state[key], int)

            # Check flags
            assert "flags" in state
            flags = state["flags"]
            for key in ["z", "n", "h", "c"]:
                assert key in flags
                assert flags[key] in (0, 1)
        finally:
            backend.close()

    def test_get_cpu_state_all_envs(self, backend: PyBoyVecMpBackend) -> None:
        """get_cpu_state() works for all environment indices."""
        try:
            backend.reset(seed=123)

            for env_idx in range(4):
                state = backend.get_cpu_state(env_idx)
                assert "pc" in state
                assert "flags" in state
        finally:
            backend.close()

    def test_get_cpu_state_invalid_idx(self, backend: PyBoyVecMpBackend) -> None:
        """get_cpu_state() raises for invalid env_idx."""
        try:
            backend.reset(seed=123)
            with pytest.raises(ValueError, match="out of range"):
                backend.get_cpu_state(10)
        finally:
            backend.close()


class TestClose:
    """Tests for close() reliability."""

    def test_close_after_reset_and_steps(self, backend: PyBoyVecMpBackend) -> None:
        """close() joins workers cleanly after work."""
        backend.reset(seed=123)
        actions = np.zeros((4,), dtype=np.int32)

        for _ in range(4):
            backend.step(actions)

        # close() should complete within timeout
        backend.close()
        assert not backend._initialized

    def test_close_idempotent(self, backend: PyBoyVecMpBackend) -> None:
        """close() can be called multiple times."""
        backend.reset(seed=123)
        backend.close()
        backend.close()  # Should not raise

    def test_close_without_work(self, backend: PyBoyVecMpBackend) -> None:
        """close() works even if never used."""
        backend.close()  # Should not raise

    def test_no_zombie_workers(self, backend: PyBoyVecMpBackend) -> None:
        """Workers are properly terminated after close."""
        backend.reset(seed=123)
        workers = backend._workers.copy()

        backend.close()

        # All workers should be terminated
        for proc in workers:
            assert not proc.is_alive()


class TestDeterministicSeeding:
    """Tests for deterministic seed derivation."""

    def test_derived_seeds_are_stable(self, backend: PyBoyVecMpBackend) -> None:
        """Same seed produces same derived seeds."""
        try:
            _, info1 = backend.reset(seed=42)
            seeds1 = info1.get("derived_seeds")

            _, info2 = backend.reset(seed=42)
            seeds2 = info2.get("derived_seeds")

            assert seeds1 is not None
            assert seeds2 is not None
            assert seeds1 == seeds2
        finally:
            backend.close()

    def test_different_seeds_produce_different_derived(
        self, backend: PyBoyVecMpBackend
    ) -> None:
        """Different base seeds produce different derived seeds."""
        try:
            _, info1 = backend.reset(seed=42)
            seeds1 = info1.get("derived_seeds")

            _, info2 = backend.reset(seed=99)
            seeds2 = info2.get("derived_seeds")

            assert seeds1 != seeds2
        finally:
            backend.close()

    def test_derived_seeds_are_unique_per_env(self, backend: PyBoyVecMpBackend) -> None:
        """Each environment gets a unique derived seed."""
        try:
            _, info = backend.reset(seed=42)
            seeds = info.get("derived_seeds")

            assert seeds is not None
            assert len(seeds) == 4
            # All seeds should be different
            assert len(set(seeds)) == 4
        finally:
            backend.close()


class TestInvalidActions:
    """Tests for invalid action handling."""

    def test_invalid_action_raises(self, backend: PyBoyVecMpBackend) -> None:
        """Invalid action index raises RuntimeError (wrapped from worker ValueError)."""
        try:
            backend.reset(seed=123)
            actions = np.array([0, 0, NUM_ACTIONS, 0], dtype=np.int32)  # One invalid
            # Worker ValueError is wrapped in RuntimeError by master
            with pytest.raises(RuntimeError, match="out of range"):
                backend.step(actions)
        finally:
            backend.close()
