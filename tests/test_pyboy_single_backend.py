"""Tests for pyboy_single backend.

Tests cover:
- Backend initialization (headless)
- reset() returns correct obs shape/dtype
- step() returns correct shapes/dtypes
- get_cpu_state() returns canonical keys and flags
- Invalid action raises ValueError
- close() stops emulator cleanly
"""

from __future__ import annotations

from pathlib import Path

import numpy as np
import pytest

from gbxcule.backends import (
    ACTION_A,
    ACTION_NOOP,
    ACTION_UP,
    NUM_ACTIONS,
)
from gbxcule.backends.pyboy_single import PyBoySingleBackend

# Path to test ROM (generated by micro-ROM builder)
ROM_PATH = Path(__file__).parent.parent / "bench" / "roms" / "out" / "ALU_LOOP.gb"


@pytest.fixture
def backend() -> PyBoySingleBackend:
    """Create a backend instance for testing."""
    if not ROM_PATH.exists():
        pytest.skip(f"Test ROM not found: {ROM_PATH}")
    return PyBoySingleBackend(str(ROM_PATH), obs_dim=32)


class TestBackendInit:
    """Tests for backend initialization."""

    def test_backend_attributes(self, backend: PyBoySingleBackend) -> None:
        """Backend has correct static attributes."""
        assert backend.name == "pyboy_single"
        assert backend.device == "cpu"
        assert backend.num_envs == 1

    def test_action_spec(self, backend: PyBoySingleBackend) -> None:
        """Action spec has correct shape and dtype."""
        spec = backend.action_spec
        assert spec.shape == (1,)
        assert spec.dtype == "int32"

    def test_obs_spec(self, backend: PyBoySingleBackend) -> None:
        """Obs spec has correct shape and dtype."""
        spec = backend.obs_spec
        assert spec.shape == (1, 32)
        assert spec.dtype == "float32"


class TestReset:
    """Tests for reset() method."""

    def test_reset_returns_obs_and_info(self, backend: PyBoySingleBackend) -> None:
        """reset() returns tuple of (obs, info)."""
        obs, info = backend.reset()
        assert isinstance(obs, np.ndarray)
        assert isinstance(info, dict)

    def test_reset_obs_shape(self, backend: PyBoySingleBackend) -> None:
        """reset() obs has shape (1, obs_dim)."""
        obs, _ = backend.reset()
        assert obs.shape == (1, 32)

    def test_reset_obs_dtype(self, backend: PyBoySingleBackend) -> None:
        """reset() obs has dtype float32."""
        obs, _ = backend.reset()
        assert obs.dtype == np.float32

    def test_reset_obs_normalized(self, backend: PyBoySingleBackend) -> None:
        """reset() obs values are in [0, 1] range."""
        obs, _ = backend.reset()
        assert np.all(obs >= 0.0)
        assert np.all(obs <= 1.0)

    def test_reset_records_seed(self, backend: PyBoySingleBackend) -> None:
        """reset() records seed in info dict."""
        _, info = backend.reset(seed=42)
        assert info["seed"] == 42

    def test_reset_can_be_called_multiple_times(
        self, backend: PyBoySingleBackend
    ) -> None:
        """reset() can be called multiple times."""
        backend.reset()
        obs, _ = backend.reset()
        assert obs.shape == (1, 32)


class TestStep:
    """Tests for step() method."""

    def test_step_noop_returns_tuple(self, backend: PyBoySingleBackend) -> None:
        """step() with noop returns 5-tuple."""
        backend.reset()
        actions = np.array([ACTION_NOOP], dtype=np.int32)
        result = backend.step(actions)
        assert len(result) == 5

    def test_step_obs_shape(self, backend: PyBoySingleBackend) -> None:
        """step() obs has correct shape."""
        backend.reset()
        actions = np.array([ACTION_NOOP], dtype=np.int32)
        obs, _, _, _, _ = backend.step(actions)
        assert obs.shape == (1, 32)

    def test_step_obs_dtype(self, backend: PyBoySingleBackend) -> None:
        """step() obs has dtype float32."""
        backend.reset()
        actions = np.array([ACTION_NOOP], dtype=np.int32)
        obs, _, _, _, _ = backend.step(actions)
        assert obs.dtype == np.float32

    def test_step_reward_shape_dtype(self, backend: PyBoySingleBackend) -> None:
        """step() reward has shape (1,) and dtype float32."""
        backend.reset()
        actions = np.array([ACTION_NOOP], dtype=np.int32)
        _, reward, _, _, _ = backend.step(actions)
        assert reward.shape == (1,)
        assert reward.dtype == np.float32

    def test_step_done_shape_dtype(self, backend: PyBoySingleBackend) -> None:
        """step() done has shape (1,) and dtype bool."""
        backend.reset()
        actions = np.array([ACTION_NOOP], dtype=np.int32)
        _, _, done, _, _ = backend.step(actions)
        assert done.shape == (1,)
        assert done.dtype == np.bool_

    def test_step_trunc_shape_dtype(self, backend: PyBoySingleBackend) -> None:
        """step() trunc has shape (1,) and dtype bool."""
        backend.reset()
        actions = np.array([ACTION_NOOP], dtype=np.int32)
        _, _, _, trunc, _ = backend.step(actions)
        assert trunc.shape == (1,)
        assert trunc.dtype == np.bool_

    def test_step_with_button_action(self, backend: PyBoySingleBackend) -> None:
        """step() works with non-noop actions."""
        backend.reset()
        actions = np.array([ACTION_UP], dtype=np.int32)
        obs, reward, done, trunc, info = backend.step(actions)
        assert obs.shape == (1, 32)
        assert reward.shape == (1,)

    def test_step_multiple_actions(self, backend: PyBoySingleBackend) -> None:
        """step() can be called multiple times with different actions."""
        backend.reset()
        for action in [ACTION_NOOP, ACTION_UP, ACTION_A]:
            actions = np.array([action], dtype=np.int32)
            obs, _, _, _, _ = backend.step(actions)
            assert obs.shape == (1, 32)

    def test_step_without_reset_raises(self, backend: PyBoySingleBackend) -> None:
        """step() without reset raises RuntimeError."""
        actions = np.array([ACTION_NOOP], dtype=np.int32)
        with pytest.raises(RuntimeError, match="not initialized"):
            backend.step(actions)


class TestGetCpuState:
    """Tests for get_cpu_state() method."""

    def test_get_cpu_state_returns_dict(self, backend: PyBoySingleBackend) -> None:
        """get_cpu_state() returns a dict."""
        backend.reset()
        state = backend.get_cpu_state(0)
        assert isinstance(state, dict)

    def test_get_cpu_state_has_registers(self, backend: PyBoySingleBackend) -> None:
        """get_cpu_state() returns all canonical register keys."""
        backend.reset()
        state = backend.get_cpu_state(0)

        # Check all registers are present
        register_keys = ["pc", "sp", "a", "f", "b", "c", "d", "e", "h", "l"]
        for key in register_keys:
            assert key in state, f"Missing register: {key}"
            assert isinstance(state[key], int), f"Register {key} should be int"

    def test_get_cpu_state_has_flags(self, backend: PyBoySingleBackend) -> None:
        """get_cpu_state() includes flags dict."""
        backend.reset()
        state = backend.get_cpu_state(0)

        assert "flags" in state
        flags = state["flags"]
        assert isinstance(flags, dict)
        for key in ["z", "n", "h", "c"]:
            assert key in flags, f"Missing flag: {key}"
            assert flags[key] in (0, 1), f"Flag {key} should be 0 or 1"

    def test_get_cpu_state_flags_derived_from_f(
        self, backend: PyBoySingleBackend
    ) -> None:
        """get_cpu_state() flags are correctly derived from F register."""
        backend.reset()
        state = backend.get_cpu_state(0)

        f = state["f"]
        flags = state["flags"]

        # Verify flag derivation
        assert flags["z"] == ((f >> 7) & 1)
        assert flags["n"] == ((f >> 6) & 1)
        assert flags["h"] == ((f >> 5) & 1)
        assert flags["c"] == ((f >> 4) & 1)

    def test_get_cpu_state_register_ranges(self, backend: PyBoySingleBackend) -> None:
        """get_cpu_state() registers are in valid ranges."""
        backend.reset()
        state = backend.get_cpu_state(0)

        # 16-bit registers
        assert 0 <= state["pc"] <= 0xFFFF
        assert 0 <= state["sp"] <= 0xFFFF

        # 8-bit registers
        for reg in ["a", "f", "b", "c", "d", "e", "h", "l"]:
            assert 0 <= state[reg] <= 0xFF, f"Register {reg} out of range"

    def test_get_cpu_state_has_counters(self, backend: PyBoySingleBackend) -> None:
        """get_cpu_state() includes counter fields (may be None)."""
        backend.reset()
        state = backend.get_cpu_state(0)

        assert "instr_count" in state
        assert "cycle_count" in state
        # PyBoy doesn't provide these, so they should be None
        assert state["instr_count"] is None
        assert state["cycle_count"] is None

    def test_get_cpu_state_invalid_env_idx(self, backend: PyBoySingleBackend) -> None:
        """get_cpu_state() raises ValueError for invalid env_idx."""
        backend.reset()
        with pytest.raises(ValueError, match="env_idx must be 0"):
            backend.get_cpu_state(1)

    def test_get_cpu_state_without_reset_raises(
        self, backend: PyBoySingleBackend
    ) -> None:
        """get_cpu_state() without reset raises RuntimeError."""
        with pytest.raises(RuntimeError, match="not initialized"):
            backend.get_cpu_state(0)


class TestInvalidActions:
    """Tests for invalid action handling."""

    def test_invalid_action_negative(self, backend: PyBoySingleBackend) -> None:
        """Negative action index raises ValueError."""
        backend.reset()
        actions = np.array([-1], dtype=np.int32)
        with pytest.raises(ValueError, match="out of range"):
            backend.step(actions)

    def test_invalid_action_too_large(self, backend: PyBoySingleBackend) -> None:
        """Action index >= NUM_ACTIONS raises ValueError."""
        backend.reset()
        actions = np.array([NUM_ACTIONS], dtype=np.int32)
        with pytest.raises(ValueError, match="out of range"):
            backend.step(actions)

    def test_valid_actions_all_work(self, backend: PyBoySingleBackend) -> None:
        """All valid action indices [0, NUM_ACTIONS) work."""
        backend.reset()
        for action in range(NUM_ACTIONS):
            actions = np.array([action], dtype=np.int32)
            # Should not raise
            obs, _, _, _, _ = backend.step(actions)
            assert obs.shape == (1, 32)


class TestClose:
    """Tests for close() method."""

    def test_close_stops_emulator(self, backend: PyBoySingleBackend) -> None:
        """close() stops the emulator."""
        backend.reset()
        backend.close()
        # After close, _pyboy should be None
        assert backend._pyboy is None

    def test_close_can_be_called_multiple_times(
        self, backend: PyBoySingleBackend
    ) -> None:
        """close() can be called multiple times without error."""
        backend.reset()
        backend.close()
        backend.close()  # Should not raise

    def test_close_without_reset(self, backend: PyBoySingleBackend) -> None:
        """close() without reset doesn't error."""
        backend.close()  # Should not raise

    def test_reset_after_close(self, backend: PyBoySingleBackend) -> None:
        """reset() works after close()."""
        backend.reset()
        backend.close()
        obs, _ = backend.reset()
        assert obs.shape == (1, 32)
