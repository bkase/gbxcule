"""Pytest configuration and shared fixtures/base classes for backend tests.

This module provides a reusable compliance test suite that can be inherited
by any backend test class to reduce code duplication.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import cast

import numpy as np
import pytest

from gbxcule.backends.common import Stage, VecBackend


@pytest.fixture(scope="session", autouse=True)
def warmup_warp_kernels() -> None:
    """Pre-compile Warp CPU kernels once for all tests (session-scoped).

    This avoids paying the ~1s compilation cost per-test when creating
    WarpVecCpuBackend instances.
    """
    # Skip if CUDA-only or Warp warmup explicitly disabled
    if os.environ.get("GBXCULE_SKIP_WARP_WARMUP"):
        return

    # Prefer release kernels for faster CPU test runs unless overridden.
    os.environ.setdefault("GBXCULE_WARP_MODE", "release")

    from gbxcule.kernels.cpu_step import warmup_warp_cpu

    stages_env = os.environ.get("GBXCULE_WARP_WARMUP_STAGES")
    valid_stages: tuple[Stage, ...] = (
        "emulate_only",
        "full_step",
        "reward_only",
        "obs_only",
    )
    if stages_env:
        if stages_env.lower() == "all":
            stages = valid_stages
        else:
            stages = tuple(
                s.strip() for s in stages_env.split(",") if s.strip() in valid_stages
            )
    else:
        # Default to minimal warmup for fast unit tests.
        stages = ("emulate_only",)

    # Warm up selected stages (obs_dim=32 is standard)
    for stage in stages:
        warmup_warp_cpu(stage=cast(Stage, stage), obs_dim=32)


# Path to test ROM (generated by micro-ROM builder)
ROM_PATH = Path(__file__).parent.parent / "bench" / "roms" / "out" / "ALU_LOOP.gb"


def require_rom(path: Path) -> None:
    """Assert that a ROM exists for tests that depend on it."""
    assert path.exists(), f"Test ROM not found: {path}. Run `make roms` first."


class BackendComplianceTests:
    """Base class providing compliance tests for any VecBackend implementation.

    Subclasses must implement the `backend` fixture to provide a configured
    backend instance for testing.
    """

    # Subclasses must set these class attributes
    expected_name: str = ""
    expected_num_envs: int = 1
    obs_dim: int = 32

    @pytest.fixture
    def backend(self) -> VecBackend:
        """Create a backend instance for testing. Must be implemented by subclass."""
        raise NotImplementedError("Subclass must implement backend fixture")

    def _valid_action(self, backend: VecBackend, idx: int) -> int:
        """Return a valid action index for a given backend."""
        if getattr(backend, "num_actions", 0) < 1:
            raise AssertionError("backend.num_actions must be >= 1")
        return min(idx, backend.num_actions - 1)

    # --- Backend Init Tests ---

    def test_backend_name(self, backend: VecBackend) -> None:
        """Backend has correct name attribute."""
        assert backend.name == self.expected_name

    def test_backend_device(self, backend: VecBackend) -> None:
        """Backend has device attribute."""
        assert backend.device == "cpu"

    def test_backend_num_envs(self, backend: VecBackend) -> None:
        """Backend has correct num_envs attribute."""
        assert backend.num_envs == self.expected_num_envs

    def test_action_spec(self, backend: VecBackend) -> None:
        """Action spec has correct shape and dtype."""
        spec = backend.action_spec
        assert spec.shape == (self.expected_num_envs,)
        assert spec.dtype == "int32"

    def test_obs_spec(self, backend: VecBackend) -> None:
        """Obs spec has correct shape and dtype."""
        spec = backend.obs_spec
        assert spec.shape == (self.expected_num_envs, self.obs_dim)
        assert spec.dtype == "float32"

    # --- Reset Tests ---

    def test_reset_returns_obs_and_info(self, backend: VecBackend) -> None:
        """reset() returns tuple of (obs, info)."""
        obs, info = backend.reset()
        assert isinstance(obs, np.ndarray)
        assert isinstance(info, dict)

    def test_reset_obs_shape(self, backend: VecBackend) -> None:
        """reset() obs has correct shape."""
        obs, _ = backend.reset()
        assert obs.shape == (self.expected_num_envs, self.obs_dim)

    def test_reset_obs_dtype(self, backend: VecBackend) -> None:
        """reset() obs has dtype float32."""
        obs, _ = backend.reset()
        assert obs.dtype == np.float32

    def test_reset_obs_normalized(self, backend: VecBackend) -> None:
        """reset() obs values are in [0, 1] range."""
        obs, _ = backend.reset()
        assert np.all(obs >= 0.0)
        assert np.all(obs <= 1.0)

    def test_reset_records_seed(self, backend: VecBackend) -> None:
        """reset() records seed in info dict."""
        _, info = backend.reset(seed=42)
        assert info["seed"] == 42

    # --- Step Tests ---

    def test_step_noop_returns_tuple(self, backend: VecBackend) -> None:
        """step() with noop returns 5-tuple."""
        backend.reset()
        action = self._valid_action(backend, 0)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        result = backend.step(actions)
        assert len(result) == 5

    def test_step_obs_shape(self, backend: VecBackend) -> None:
        """step() obs has correct shape."""
        backend.reset()
        action = self._valid_action(backend, 0)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        obs, _, _, _, _ = backend.step(actions)
        assert obs.shape == (self.expected_num_envs, self.obs_dim)

    def test_step_obs_dtype(self, backend: VecBackend) -> None:
        """step() obs has dtype float32."""
        backend.reset()
        action = self._valid_action(backend, 0)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        obs, _, _, _, _ = backend.step(actions)
        assert obs.dtype == np.float32

    def test_step_reward_shape_dtype(self, backend: VecBackend) -> None:
        """step() reward has shape (num_envs,) and dtype float32."""
        backend.reset()
        action = self._valid_action(backend, 0)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        _, reward, _, _, _ = backend.step(actions)
        assert reward.shape == (self.expected_num_envs,)
        assert reward.dtype == np.float32

    def test_step_done_shape_dtype(self, backend: VecBackend) -> None:
        """step() done has shape (num_envs,) and dtype bool."""
        backend.reset()
        action = self._valid_action(backend, 0)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        _, _, done, _, _ = backend.step(actions)
        assert done.shape == (self.expected_num_envs,)
        assert done.dtype == np.bool_

    def test_step_trunc_shape_dtype(self, backend: VecBackend) -> None:
        """step() trunc has shape (num_envs,) and dtype bool."""
        backend.reset()
        action = self._valid_action(backend, 0)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        _, _, _, trunc, _ = backend.step(actions)
        assert trunc.shape == (self.expected_num_envs,)
        assert trunc.dtype == np.bool_

    def test_step_with_button_action(self, backend: VecBackend) -> None:
        """step() works with non-noop actions."""
        backend.reset()
        action = self._valid_action(backend, 1)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        obs, reward, done, trunc, info = backend.step(actions)
        assert obs.shape == (self.expected_num_envs, self.obs_dim)
        assert reward.shape == (self.expected_num_envs,)

    def test_step_multiple_actions(self, backend: VecBackend) -> None:
        """step() can be called multiple times with different actions."""
        backend.reset()
        for idx in [0, 1, 2]:
            action = self._valid_action(backend, idx)
            actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
            obs, _, _, _, _ = backend.step(actions)
            assert obs.shape == (self.expected_num_envs, self.obs_dim)

    def test_step_without_reset_raises(self, backend: VecBackend) -> None:
        """step() without reset raises RuntimeError."""
        action = self._valid_action(backend, 0)
        actions = np.array([action] * self.expected_num_envs, dtype=np.int32)
        with pytest.raises(RuntimeError, match="not initialized"):
            backend.step(actions)

    # --- Get CPU State Tests ---

    def test_get_cpu_state_returns_dict(self, backend: VecBackend) -> None:
        """get_cpu_state() returns a dict."""
        backend.reset()
        state = backend.get_cpu_state(0)
        assert isinstance(state, dict)

    def test_get_cpu_state_has_registers(self, backend: VecBackend) -> None:
        """get_cpu_state() returns all canonical register keys."""
        backend.reset()
        state = backend.get_cpu_state(0)

        register_keys = ["pc", "sp", "a", "f", "b", "c", "d", "e", "h", "l"]
        for key in register_keys:
            assert key in state, f"Missing register: {key}"
            assert isinstance(state[key], int), f"Register {key} should be int"

    def test_get_cpu_state_has_flags(self, backend: VecBackend) -> None:
        """get_cpu_state() includes flags dict."""
        backend.reset()
        state = backend.get_cpu_state(0)

        assert "flags" in state
        flags = state["flags"]
        assert isinstance(flags, dict)
        for key in ["z", "n", "h", "c"]:
            assert key in flags, f"Missing flag: {key}"
            assert flags[key] in (0, 1), f"Flag {key} should be 0 or 1"

    def test_get_cpu_state_flags_derived_from_f(self, backend: VecBackend) -> None:
        """get_cpu_state() flags are correctly derived from F register."""
        backend.reset()
        state = backend.get_cpu_state(0)

        f = state["f"]
        flags = state["flags"]

        assert flags["z"] == ((f >> 7) & 1)
        assert flags["n"] == ((f >> 6) & 1)
        assert flags["h"] == ((f >> 5) & 1)
        assert flags["c"] == ((f >> 4) & 1)

    def test_get_cpu_state_register_ranges(self, backend: VecBackend) -> None:
        """get_cpu_state() registers are in valid ranges."""
        backend.reset()
        state = backend.get_cpu_state(0)

        # 16-bit registers
        assert 0 <= state["pc"] <= 0xFFFF
        assert 0 <= state["sp"] <= 0xFFFF

        # 8-bit registers
        for reg in ["a", "f", "b", "c", "d", "e", "h", "l"]:
            assert 0 <= state[reg] <= 0xFF, f"Register {reg} out of range"

    def test_get_cpu_state_has_counters(self, backend: VecBackend) -> None:
        """get_cpu_state() includes counter fields (may be None)."""
        backend.reset()
        state = backend.get_cpu_state(0)

        assert "instr_count" in state
        assert "cycle_count" in state

    # --- Invalid Action Tests ---

    def test_invalid_action_negative(self, backend: VecBackend) -> None:
        """Negative action index raises ValueError."""
        backend.reset()
        actions = np.array([-1] * self.expected_num_envs, dtype=np.int32)
        with pytest.raises((ValueError, RuntimeError), match="out of range"):
            backend.step(actions)

    def test_invalid_action_too_large(self, backend: VecBackend) -> None:
        """Action index >= NUM_ACTIONS raises ValueError."""
        backend.reset()
        actions = np.array(
            [backend.num_actions] * self.expected_num_envs, dtype=np.int32
        )
        with pytest.raises((ValueError, RuntimeError), match="out of range"):
            backend.step(actions)

    def test_valid_actions_all_work(self, backend: VecBackend) -> None:
        """All valid action indices [0, NUM_ACTIONS) work."""
        backend.reset()
        # Batch actions across envs to reduce step count
        num_actions = backend.num_actions
        num_envs = self.expected_num_envs
        action_idx = 0
        while action_idx < num_actions:
            # Build batch with different actions per env (pad with action 0 if needed)
            batch = []
            for env in range(num_envs):
                if action_idx + env < num_actions:
                    batch.append(action_idx + env)
                else:
                    batch.append(0)  # Pad with valid action
            actions = np.array(batch, dtype=np.int32)
            obs, _, _, _, _ = backend.step(actions)
            assert obs.shape == (num_envs, self.obs_dim)
            action_idx += num_envs

    # --- Close Tests ---

    def test_close_can_be_called_multiple_times(self, backend: VecBackend) -> None:
        """close() can be called multiple times without error."""
        backend.reset()
        backend.close()
        backend.close()  # Should not raise

    def test_close_without_reset(self, backend: VecBackend) -> None:
        """close() without reset doesn't error."""
        backend.close()  # Should not raise
